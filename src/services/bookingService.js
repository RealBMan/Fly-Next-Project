// src/services/bookingService.js
//create booking was generated by chatgpt and slightly modified
import { prisma } from '../prismaClient';

/**
 * Create a new booking.
 *
 * Given:
 *   - \( \text{data} = \{ \text{hotelId}, \text{roomTypeId}, \text{checkInDate}, \text{checkOutDate}, \text{status (optional)} \} \)
 *   - \( \text{userId} \) of the authenticated user,
 *
 * This function:
 *   - Validates that checkInDate < checkOutDate.
 *   - Checks that the room type exists and has available rooms.
 *   - Creates the booking and decrements the available room count.
 *
 * @param {Object} data - Booking details.
 * @param {number} userId - ID of the user creating the booking.
 * @returns {Promise<Object>} - The newly created booking record.
 */
export async function createBookingService(data, userId) {
  // Convert dates from input
  const checkIn = new Date(data.checkInDate);
  const checkOut = new Date(data.checkOutDate);

  // Validate date order: checkIn < checkOut
  if (checkIn >= checkOut) {
    const err = new Error("Check-in date must be before check-out date");
    err.status = 400;
    throw err;
  }

  // Retrieve the room type to check availability
  const roomType = await prisma.roomType.findUnique({
    where: { id: Number(data.roomTypeId) },
  });
  if (!roomType) {
    const err = new Error("Room type not found");
    err.status = 404;
    throw err;
  }
  if (roomType.availableRooms <= 0) {
    const err = new Error("No available rooms for the selected type");
    err.status = 400;
    throw err;
  }

  if (roomType.hotelId !== Number(data.hotelId)) {
    const err = new Error("Provided hotelId does not match the room type's hotel");
    err.status = 400;
    throw err;
  }

  // Create the booking record
  const newBooking = await prisma.booking.create({
    data: {
      userId: userId,
      hotelId: Number(data.hotelId),
      roomTypeId: Number(data.roomTypeId),
      checkInDate: checkIn,
      checkOutDate: checkOut,
      status: data.status || "confirmed",
    },
  });

  const hotel = await prisma.hotel.findUnique({
    where: { id: Number(data.hotelId) },
  });

  await prisma.notification.create({
    data: {
      userId: hotel.ownerId,
      message: `Booking created for ${userId} confirmed for ${roomType.name} at ${hotel.name}`,
    },
  });

  const not = prisma.notification.findUnique({
    where: { userId: userId },});

  await prisma.notification.create({
    data: {
      userId: userId,
      message: `Booking created for ${userId} confirmed for ${roomType.name} at ${hotel.name}`,
    },
  });

  await prisma.roomType.update({
    where: { id: Number(data.roomTypeId) },
    data: { availableRooms: roomType.availableRooms},
  });

  return newBooking;
}

/**
 * List all bookings for a given user.
 *
 */
export async function filterHotelBookingsService(userId, filters = {}, view) {
  try {
    // Build the base filter: if view is "owner", filter by hotel.ownerId; otherwise, filter by booking.userId.
    const whereClause = view === "owner" 
      ? { hotel: { ownerId: userId } } 
      : { userId: userId };

    // If filtering by room type, add that condition.
    if (filters.roomTypeId) {
      whereClause.roomTypeId = Number(filters.roomTypeId);
    }

    // If filtering by date range, only include bookings that overlap with the period.
    if (filters.startDate && filters.endDate) {
      whereClause.AND = [
        { checkInDate: { lte: new Date(filters.endDate) } },
        { checkOutDate: { gte: new Date(filters.startDate) } }
      ];
    }

    // Fetch bookings with filtering applied.
    const bookings = await prisma.booking.findMany({
      where: whereClause,
      include: { hotel: true, roomType: true },
      orderBy: { createdAt: 'desc' },
    });
    return bookings;
  } catch (error) {
    throw new Error("Failed to filter bookings: " + error.message);
  }
}


/**
 * Cancel an existing booking.
 *
 * Given:
 *   - \( \text{bookingId} \) and \( \text{userId} \),
 *
 * This function:
 *   - Ensures the booking exists and belongs to the user.
 *   - Updates the booking's status to "cancelled".
 *   - Increments the available rooms for the associated room type.
 *
 * @param {number} bookingId - ID of the booking to cancel.
 * @param {number} userId - ID of the authenticated user.
 * @returns {Promise<Object>} - The updated booking record.
 */
export async function cancelBookingService(bookingId, userId) {
  // Retrieve the booking, including its roomType and hotel details
  const booking = await prisma.booking.findUnique({
    where: { id: Number(bookingId) },
    include: { roomType: true, hotel: true },
  });
  if (!booking) {
    const err = new Error("Booking not found");
    err.status = 404;
    throw err;
  }
  // Allow cancellation if the authenticated user is either:
  // - The user who made the booking, OR
  // - The owner of the hotel for this booking.
  if (booking.userId !== userId && booking.hotel.ownerId !== userId) {
    const err = new Error("Unauthorized to cancel this booking");
    err.status = 403;
    throw err;
  }
  
  // Update the booking status to 'cancelled'
  const cancelledBooking = await prisma.booking.update({
    where: { id: Number(bookingId) },
    data: { status: "cancelled" },
  });
  
  // Use the already included roomType and hotel details
  const roomType = booking.roomType;
  const hotel = booking.hotel;
  
  // Create notifications with appropriate cancellation messages
  await prisma.notification.create({
    data: {
      userId: hotel.ownerId,
      message: `Booking for ${roomType.name} at ${hotel.name} has been cancelled by user ${userId}.`,
    },
  });
  
  await prisma.notification.create({
    data: {
      userId: userId,
      message: `Your booking for ${roomType.name} at ${hotel.name} has been cancelled.`,
    },
  });
  
  // Update the room availability: increment availableRooms by 1
  if (roomType) {
    await prisma.roomType.update({
      where: { id: booking.roomTypeId },
      data: { availableRooms: roomType.availableRooms},
    });
  }
  
  return cancelledBooking;
}
